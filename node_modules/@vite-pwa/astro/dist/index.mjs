import { fileURLToPath } from 'node:url';
import { VitePWA } from 'vite-plugin-pwa';

function index(options = {}) {
  const ctx = {
    api: void 0,
    previewOrSync: false,
    doBuild: false,
    scope: "/",
    trailingSlash: "ignore",
    useDirectoryFormat: true
  };
  const astroPWAContext = () => {
    return ctx;
  };
  return {
    name: "@vite-pwa/astro-integration",
    hooks: {
      "astro:config:setup": ({ command, config, updateConfig }) => {
        if (command === "preview" || command === "sync") {
          ctx.previewOrSync = true;
          return;
        }
        ctx.scope = config.base ?? config.vite.base ?? "/";
        ctx.trailingSlash = config.trailingSlash;
        ctx.useDirectoryFormat = config.build.format === "directory";
        let plugins = getViteConfiguration(
          config,
          options,
          ctx.useDirectoryFormat,
          astroPWAContext
        );
        plugins = plugins.filter((p) => "name" in p && p.name !== "vite-plugin-pwa:build");
        if (command === "build") {
          plugins = plugins.filter((p) => "name" in p && p.name !== "vite-plugin-pwa:dev-sw");
          plugins.push({
            name: "vite-pwa:astro:build:plugin",
            // @ts-expect-error using Vite 5, env. api missing
            applyToEnvironment(env) {
              return env.name === "client";
            },
            configResolved(resolvedConfig) {
              if (!resolvedConfig.build.ssr)
                ctx.api = resolvedConfig.plugins.flat(Number.POSITIVE_INFINITY).find((p) => p.name === "vite-plugin-pwa")?.api;
            },
            async generateBundle(_, bundle) {
              const api = ctx.api;
              if (api) {
                const pwaAssetsGenerator = await api.pwaAssetsGenerator();
                if (pwaAssetsGenerator) {
                  pwaAssetsGenerator.injectManifestIcons();
                }
                api.generateBundle(bundle, this);
              }
            },
            closeBundle: {
              sequential: true,
              order: "post",
              async handler() {
                const api = ctx.api;
                const pwaAssetsGenerator = api && await api.pwaAssetsGenerator();
                if (pwaAssetsGenerator)
                  await pwaAssetsGenerator.generate();
              }
            }
          });
        }
        updateConfig({
          vite: {
            // @ts-expect-error TS2322: Type Plugin<any>[] is not assignable to type DeepPartial<PluginOption[] | undefined
            plugins
          }
        });
      },
      "astro:build:done": async () => {
        if (ctx.previewOrSync)
          return;
        ctx.doBuild = true;
        const api = ctx.api;
        if (api && !api.disabled) {
          await api.generateSW();
        }
      }
    }
  };
}
function createManifestTransform(astroPWAContext) {
  return async (entries) => {
    const { doBuild, trailingSlash, scope, useDirectoryFormat } = astroPWAContext();
    if (!doBuild)
      return { manifest: entries, warnings: [] };
    entries.filter((e) => e && e.url.endsWith(".html")).forEach((e) => {
      const url = e.url.startsWith("/") ? e.url.slice(1) : e.url;
      if (url === "index.html") {
        e.url = scope;
      } else {
        const parts = url.split("/");
        parts[parts.length - 1] = parts[parts.length - 1].replace(/\.html$/, "");
        e.url = useDirectoryFormat ? parts.length > 1 ? parts.slice(0, parts.length - 1).join("/") : parts[0] : parts.join("/");
        if (trailingSlash === "always")
          e.url += "/";
      }
    });
    return { manifest: entries, warnings: [] };
  };
}
function createExperimentalManifestTransform(astroPWAContext) {
  return async (entries) => {
    const { doBuild, trailingSlash, scope, useDirectoryFormat } = astroPWAContext();
    if (!doBuild)
      return { manifest: entries, warnings: [] };
    const additionalEntries = [];
    entries.filter((e) => e && e.url.endsWith(".html")).forEach((e) => {
      const url = e.url.startsWith("/") ? e.url.slice(1) : e.url;
      if (url === "index.html") {
        additionalEntries.push({
          revision: e.revision,
          url: scope,
          size: e.size
        });
      } else if (url === "404.html") {
        e.url = `404${trailingSlash === "always" ? "/" : ""}`;
      } else {
        const parts = url.split("/");
        parts[parts.length - 1] = parts[parts.length - 1].replace(/\.html$/, "");
        let newUrl = useDirectoryFormat ? parts.length > 1 ? parts.slice(0, parts.length - 1).join("/") : parts[0] : parts.join("/");
        if (trailingSlash === "always")
          newUrl += "/";
        additionalEntries.push({
          revision: e.revision,
          url: newUrl,
          size: e.size
        });
      }
    });
    if (additionalEntries.length)
      entries.push(...additionalEntries);
    return { manifest: entries, warnings: [] };
  };
}
function getViteConfiguration(config, options, directoryFormat, astroPWAContext) {
  const plugin = config.vite?.plugins?.flat(Number.POSITIVE_INFINITY).find((p) => p.name === "vite-plugin-pwa");
  if (plugin)
    throw new Error("Remove the vite-plugin-pwa plugin from Vite Plugins entry in Astro config file, configure it via @vite-pwa/astro integration");
  options.includeManifestIcons = false;
  const server = config.output === "server";
  if (server) {
    options.outDir = fileURLToPath(config.build.client);
  }
  if (options.pwaAssets) {
    options.pwaAssets.integration = {
      baseUrl: config.base ?? config.vite.base ?? "/",
      publicDir: fileURLToPath(config.publicDir),
      outDir: server ? options.outDir : fileURLToPath(config.outDir)
    };
  }
  const {
    strategies = "generateSW",
    registerType = "prompt",
    injectRegister,
    workbox = {},
    ...rest
  } = options;
  let assets = config.build.assets ?? "_astro/";
  if (assets[0] === "/") {
    assets = assets.slice(1);
  }
  if (assets[assets.length - 1] !== "/") {
    assets += "/";
  }
  if (strategies === "generateSW") {
    const useWorkbox = { ...workbox };
    const newOptions = {
      ...rest,
      strategies,
      registerType,
      injectRegister
    };
    if (server) {
      useWorkbox.globDirectory = options.outDir;
    }
    if (!("navigateFallback" in useWorkbox))
      useWorkbox.navigateFallback = config.base ?? config.vite?.base ?? "/";
    if (directoryFormat)
      useWorkbox.directoryIndex = "index.html";
    newOptions.workbox = useWorkbox;
    if (!("dontCacheBustURLsMatching" in newOptions.workbox))
      newOptions.workbox.dontCacheBustURLsMatching = new RegExp(assets);
    if (!newOptions.workbox.manifestTransforms) {
      newOptions.workbox.manifestTransforms = newOptions.workbox.manifestTransforms ?? [];
      newOptions.workbox.manifestTransforms.push(
        options.experimental?.directoryAndTrailingSlashHandler === true ? createExperimentalManifestTransform(astroPWAContext) : createManifestTransform(astroPWAContext)
      );
    }
    return VitePWA(newOptions);
  }
  options.injectManifest = options.injectManifest ?? {};
  if (server) {
    options.injectManifest.globDirectory = options.outDir;
  }
  if (!("dontCacheBustURLsMatching" in options.injectManifest))
    options.injectManifest.dontCacheBustURLsMatching = new RegExp(assets);
  if (!options.injectManifest.manifestTransforms) {
    options.injectManifest.manifestTransforms = options.injectManifest.manifestTransforms ?? [];
    options.injectManifest.manifestTransforms.push(
      options.experimental?.directoryAndTrailingSlashHandler === true ? createExperimentalManifestTransform(astroPWAContext) : createManifestTransform(astroPWAContext)
    );
  }
  return VitePWA(options);
}

export { index as default };
